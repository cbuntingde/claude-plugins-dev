#!/usr/bin/env node
/**
 * MCP Server for Vulnerability Database Queries
 *
 * Provides tools to query multiple vulnerability databases:
 * - OSV (Open Source Vulnerabilities) - osv.dev API
 * - npm Security Advisories
 * - GitHub Advisory Database
 * - NVD (National Vulnerability Database)
 *
 * Uses SQLite for local caching of vulnerability data.
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { mkdirSync, existsSync } from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

// Severity order for filtering
const SEVERITY_ORDER = ['low', 'moderate', 'high', 'critical'];

/**
 * Vulnerability Database Server
 * Aggregates vulnerability data from multiple sources with SQLite caching
 */
class VulnerabilityDBServer {
  constructor() {
    // Database path from environment or default
    this.dbPath = process.env.DB_PATH || join(__dirname, '../../data/vulnerability.db');
    this.cacheTTL = parseInt(process.env.VULN_CACHE_TTL || '86400000', 10); // 24 hours

    // Ensure data directory exists
    const dbDir = dirname(this.dbPath);
    if (!existsSync(dbDir)) {
      mkdirSync(dbDir, { recursive: true });
    }

    // Initialize SQLite database
    this.initDatabase().then(db => {
      this.db = db;
    }).catch(err => {
      console.error('Failed to initialize database:', err);
    });

    this.server = new Server(
      {
        name: 'dependency-vulnerability-db',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
  }

  /**
   * Initialize SQLite database with required tables
   */
  async initDatabase() {
    try {
      const Database = (await import('better-sqlite3')).default;
      const db = new Database(this.dbPath);

      // Create tables for caching vulnerabilities
      db.exec(`
        CREATE TABLE IF NOT EXISTS vulnerabilities (
          id TEXT PRIMARY KEY,
          ecosystem TEXT NOT NULL,
          package TEXT NOT NULL,
          version TEXT,
          source TEXT NOT NULL,
          data TEXT NOT NULL,
          cached_at INTEGER NOT NULL,
          expires_at INTEGER NOT NULL
        );

        CREATE TABLE IF NOT EXISTS cve_cache (
          cve_id TEXT PRIMARY KEY,
          data TEXT NOT NULL,
          cached_at INTEGER NOT NULL,
          expires_at INTEGER NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_vuln_package ON vulnerabilities(package, ecosystem);
        CREATE INDEX IF NOT EXISTS idx_vuln_expires ON vulnerabilities(expires_at);
      `);

      return db;
    } catch (error) {
      console.error('Database initialization error:', error);
      throw error;
    }
  }

  /**
   * Set up tool handlers for vulnerability queries
   */
  setupToolHandlers() {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'query_vulnerabilities',
            description: `Query vulnerability databases for a package

Returns comprehensive vulnerability information from multiple sources:
- Known CVEs and their severity
- Patch availability
- Exploit status
- Affected versions
- Remediation guidance

Example: Query vulnerabilities for lodash@4.17.15`,
            inputSchema: {
              type: 'object',
              properties: {
                package: {
                  type: 'string',
                  description: 'Package name (e.g., "lodash")',
                },
                version: {
                  type: 'string',
                  description: 'Package version (e.g., "4.17.15")',
                },
                ecosystem: {
                  type: 'string',
                  description: 'Package ecosystem (npm, pypi, maven, etc.)',
                  default: 'npm',
                  enum: ['npm', 'pypi', 'maven', 'go', 'cargo', 'nuget'],
                },
                severity: {
                  type: 'string',
                  description: 'Minimum severity to report',
                  default: 'low',
                  enum: ['low', 'moderate', 'high', 'critical'],
                },
              },
              required: ['package'],
            },
          },
          {
            name: 'batch_query_vulnerabilities',
            description: `Query vulnerabilities for multiple packages at once

Efficiently check multiple packages for vulnerabilities in a single call.
Useful for scanning entire dependency trees.`,
            inputSchema: {
              type: 'object',
              properties: {
                packages: {
                  type: 'array',
                  items: {
                    type: 'object',
                    properties: {
                      name: {
                        type: 'string',
                        description: 'Package name',
                      },
                      version: {
                        type: 'string',
                        description: 'Package version (optional)',
                      },
                    },
                    required: ['name'],
                  },
                  description: 'Array of packages to query',
                },
                ecosystem: {
                  type: 'string',
                  description: 'Package ecosystem',
                  default: 'npm',
                  enum: ['npm', 'pypi', 'maven', 'go', 'cargo', 'nuget'],
                },
              },
              required: ['packages'],
            },
          },
          {
            name: 'check_cve',
            description: `Lookup specific CVE details

Returns detailed information about a specific CVE including:
- CVSS score and severity
- Affected packages and versions
- Patch availability
- Published and modified dates
- References and advisories`,
            inputSchema: {
              type: 'object',
              properties: {
                cveId: {
                  type: 'string',
                  description: 'CVE identifier (e.g., "CVE-2021-23337")',
                  pattern: '^CVE-\\d{4}-\\d{4,}$',
                },
              },
              required: ['cveId'],
            },
          },
          {
            name: 'get_advisories',
            description: `Get security advisories for a package

Returns official security advisories from OSV and GitHub databases`,
            inputSchema: {
              type: 'object',
              properties: {
                package: {
                  type: 'string',
                  description: 'Package name',
                },
                ecosystem: {
                  type: 'string',
                  description: 'Package ecosystem',
                  default: 'npm',
                },
              },
              required: ['package'],
            },
          },
        ],
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'query_vulnerabilities':
            return await this.queryVulnerabilities(args);

          case 'batch_query_vulnerabilities':
            return await this.batchQueryVulnerabilities(args);

          case 'check_cve':
            return await this.checkCVE(args);

          case 'get_advisories':
            return await this.getAdvisories(args);

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify({
                error: error.message,
                stack: error.stack,
              }),
            },
          ],
        };
      }
    });
  }

  /**
   * Query vulnerabilities for a single package
   */
  async queryVulnerabilities({ package, version, ecosystem = 'npm', severity = 'low' }) {
    const cacheKey = `${ecosystem}:${package}${version ? '@' + version : ''}`;

    // Check cache first
    const cached = this.getFromCache(cacheKey);
    if (cached) {
      const filtered = this.filterBySeverity(cached.vulnerabilities, severity);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              package: `${package}@${version || 'latest'}`,
              ecosystem,
              queriedAt: new Date().toISOString(),
              cached: true,
              totalVulnerabilities: filtered.length,
              vulnerabilities: filtered,
              summary: this.summarizeVulnerabilities(filtered),
            }, null, 2),
          },
        ],
      };
    }

    // Fetch from external APIs
    const vulnerabilities = await this.fetchFromVulnDatabases(package, version, ecosystem);

    // Cache the results
    this.saveToCache(cacheKey, { package, version, ecosystem, vulnerabilities });

    const filtered = this.filterBySeverity(vulnerabilities, severity);

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            package: `${package}@${version || 'latest'}`,
            ecosystem,
            queriedAt: new Date().toISOString(),
            cached: false,
            totalVulnerabilities: filtered.length,
            vulnerabilities: filtered,
            summary: this.summarizeVulnerabilities(filtered),
          }, null, 2),
        },
      ],
    };
  }

  /**
   * Query vulnerabilities for multiple packages
   */
  async batchQueryVulnerabilities({ packages, ecosystem = 'npm' }) {
    const results = await Promise.all(
      packages.map(({ name, version }) =>
        this.queryVulnerabilities({ package: name, version, ecosystem })
      )
    );

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            batchResults: results.map(r => JSON.parse(r.content[0].text)),
            summary: {
              totalPackages: packages.length,
              packagesWithVulns: results.filter(r => {
                const data = JSON.parse(r.content[0].text);
                return data.totalVulnerabilities > 0;
              }).length,
            },
          }, null, 2),
        },
      ],
    };
  }

  /**
   * Lookup specific CVE details
   */
  async checkCVE({ cveId }) {
    // Check cache first
    const cached = this.getCVEFromCache(cveId);
    if (cached) {
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({ ...cached, cached: true }, null, 2),
          },
        ],
      };
    }

    // Fetch from NVD or OSV API
    const cveData = await this.fetchCVEDetails(cveId);

    if (cveData) {
      this.saveCVEToCache(cveId, cveData);
    }

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ ...cveData, cached: false }, null, 2),
        },
      ],
    };
  }

  /**
   * Get security advisories for a package
   */
  async getAdvisories({ package, ecosystem = 'npm' }) {
    const advisories = await this.fetchAdvisories(package, ecosystem);

    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            package,
            ecosystem,
            advisoryCount: advisories.length,
            advisories,
          }, null, 2),
        },
      ],
    };
  }

  /**
   * Fetch vulnerabilities from OSV API
   */
  async fetchFromOSV(package, version, ecosystem) {
    const ecosystemMap = {
      'npm': 'npm',
      'pypi': 'pypi',
      'maven': 'maven',
      'go': 'go',
      'cargo': 'crates.io',
      'nuget': 'nuget',
    };

    const mappedEcosystem = ecosystemMap[ecosystem] || ecosystem;

    try {
      const response = await fetch('https://api.osv.dev/v1/query', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          package: { name: package, ecosystem: mappedEcosystem },
          version: version,
        }),
      });

      if (!response.ok) {
        console.error(`OSV API error: ${response.status}`);
        return [];
      }

      const data = await response.json();
      return (data.vulns || []).map(vuln => this.normalizeOSVVuln(vuln, package));
    } catch (error) {
      console.error('OSV fetch error:', error.message);
      return [];
    }
  }

  /**
   * Normalize OSV vulnerability to common format
   */
  normalizeOSVVuln(vuln, package) {
    const severity = this.calculateSeverity(vuln.severity || vuln.cvss || []);
    return {
      id: vuln.id,
      title: vuln.summary?.substring(0, 200) || 'Unknown vulnerability',
      description: vuln.details || '',
      severity,
      cvssScore: vuln.cvss?.base_metric?.cvss?.score || null,
      cweId: vuln.cwe?.cweId || null,
      affectedVersions: this.parseAffectedVersions(vuln.affected),
      references: (vuln.references || []).map(r => r.url),
      published: vuln.published,
      modified: vuln.modified,
      source: 'OSV',
      proposedFix: vuln.fix_version || null,
    };
  }

  /**
   * Parse affected versions from OSV format
   */
  parseAffectedVersions(affected) {
    if (!affected || !affected.length) return [];
    const versions = [];
    for (const a of affected) {
      for (const range of a.ranges || []) {
        for (const event of range.events || []) {
          if (event.introduced) versions.push({ type: 'introduced', version: event.introduced });
          if (event.fixed) versions.push({ type: 'fixed', version: event.fixed });
          if (event.limit) versions.push({ type: 'limit', version: event.limit });
        }
      }
    }
    return versions;
  }

  /**
   * Fetch from npm Security Advisories API
   */
  async fetchFromNPMAdvisories(package, version) {
    try {
      const response = await fetch(
        `https://api.npmjs.org/advisories/${package}`,
        { headers: { 'Accept': 'application/json' } }
      );

      if (!response.ok) {
        if (response.status === 404) return [];
        throw new Error(`NPM API error: ${response.status}`);
      }

      const data = await response.json();
      return (data.advisories || []).map(vuln => this.normalizeNPMVuln(vuln, package));
    } catch (error) {
      console.error('NPM advisories fetch error:', error.message);
      return [];
    }
  }

  /**
   * Normalize npm vulnerability to common format
   */
  normalizeNPMVuln(vuln, package) {
    const severity = vuln.severity || 'moderate';
    return {
      id: vuln.id?.toString(),
      title: vuln.title || 'Security vulnerability',
      description: vuln.overview || '',
      severity: severity.toLowerCase(),
      cvssScore: vuln.cvss_score || null,
      cweId: vuln.cwe?.split(',')[0]?.trim() || null,
      affectedVersions: this.parseNPMVersions(vuln.vulnerable_versions),
      references: (vuln.references || []).map(r => r.url).filter(Boolean),
      published: vuln.reported,
      modified: vuln.updated,
      source: 'npm',
      proposedFix: null,
    };
  }

  /**
   * Parse npm version ranges
   */
  parseNPMVersions(rangeStr) {
    if (!rangeStr) return [];
    return [{ type: 'range', version: rangeStr }];
  }

  /**
   * Fetch vulnerabilities from multiple databases
   */
  async fetchFromVulnDatabases(package, version, ecosystem) {
    const [osvVulns, npmVulns] = await Promise.allSettled([
      this.fetchFromOSV(package, version, ecosystem),
      ecosystem === 'npm' ? this.fetchFromNPMAdvisories(package, version) : Promise.resolve([]),
    ]);

    const osvResults = osvVulns.status === 'fulfilled' ? osvVulns.value : [];
    const npmResults = npmVulns.status === 'fulfilled' ? npmVulns.value : [];

    // Deduplicate by vulnerability ID
    const seen = new Set();
    const combined = [];
    for (const vuln of [...npmResults, ...osvResults]) {
      if (!seen.has(vuln.id)) {
        seen.add(vuln.id);
        combined.push(vuln);
      }
    }

    return combined;
  }

  /**
   * Fetch CVE details from NVD
   */
  async fetchCVEDetails(cveId) {
    try {
      // Use NVD API 2.0
      const response = await fetch(
        `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`,
        { headers: { 'Accept': 'application/json' } }
      );

      if (!response.ok) {
        // Fallback to OSV for CVE lookup
        return this.fetchCVEFromOSV(cveId);
      }

      const data = await response.json();
      const vuln = data.vulnerabilities?.[0]?.cve;
      if (!vuln) return null;

      return this.normalizeNCVE(vuln, cveId);
    } catch (error) {
      console.error('NVD fetch error:', error.message);
      return this.fetchCVEFromOSV(cveId);
    }
  }

  /**
   * Fetch CVE from OSV as fallback
   */
  async fetchCVEFromOSV(cveId) {
    try {
      const response = await fetch('https://api.osv.dev/v1/query', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ cve_id: cveId }),
      });

      if (!response.ok) return null;
      const data = await response.json();
      if (!data.vulns?.[0]) return null;

      return {
        cveId,
        description: data.vulns[0].summary || '',
        severity: this.calculateSeverity(data.vulns[0].severity),
        cvssScore: data.vulns[0].cvss?.base_metric?.cvss?.score || null,
        published: data.vulns[0].published,
        modified: data.vulns[0].modified,
        references: (data.vulns[0].references || []).map(r => r.url).filter(Boolean),
        affectedPackages: data.vulns[0].affected?.map(a => ({
          package: a.package?.name,
          ecosystem: a.package?.ecosystem,
        })) || [],
      };
    } catch (error) {
      console.error('OSV CVE fetch error:', error.message);
      return null;
    }
  }

  /**
   * Normalize NVD CVE data
   */
  normalizeNCVE(vuln, cveId) {
    const metrics = vuln.metrics?.cvssMetricV31?.[0]?.cvssData ||
      vuln.metrics?.cvssMetricV30?.[0]?.cvssData || {};
    const description = vuln.descriptions?.find(d => d.lang === 'en')?.value ||
      vuln.description?.description_data?.[0]?.value || '';

    return {
      cveId,
      description,
      severity: metrics.baseSeverity || 'UNKNOWN',
      cvssScore: metrics.baseScore || null,
      published: vuln.published?.date,
      modified: vuln.lastModified?.date,
      references: (vuln.references?.reference_data || [])
        .map(r => r.url)
        .filter(Boolean),
      affectedPackages: (vuln.affects?.vendor?.vendor_data?.[0]?.product?.product_data || [])
        .map(p => ({
          package: p.product?.product_data?.[0]?.product_name,
          version: p.affected?.version_data?.[0]?.version_value,
        }))
        .filter(p => p.package),
    };
  }

  /**
   * Fetch security advisories
   */
  async fetchAdvisories(package, ecosystem) {
    const vulnerabilities = await this.fetchFromVulnDatabases(package, null, ecosystem);
    return vulnerabilities.map(v => ({
      id: v.id,
      title: v.title,
      severity: v.severity,
      published: v.published,
      source: v.source,
    }));
  }

  /**
   * Calculate severity from available data
   */
  calculateSeverity(severityData) {
    if (!severityData) return 'moderate';

    if (typeof severityData === 'string') {
      const normalized = severityData.toLowerCase();
      if (SEVERITY_ORDER.includes(normalized)) return normalized;
      return 'moderate';
    }

    if (typeof severityData === 'object' && severityData.baseSeverity) {
      const normalized = severityData.baseSeverity.toLowerCase();
      if (SEVERITY_ORDER.includes(normalized)) return normalized;
    }

    return 'moderate';
  }

  /**
   * Filter vulnerabilities by minimum severity
   */
  filterBySeverity(vulnerabilities, minSeverity) {
    const minIndex = SEVERITY_ORDER.indexOf(minSeverity);
    return vulnerabilities.filter(v => {
      const vulnIndex = SEVERITY_ORDER.indexOf(v.severity || 'moderate');
      return vulnIndex >= minIndex;
    });
  }

  /**
   * Generate vulnerability summary
   */
  summarizeVulnerabilities(vulnerabilities) {
    return {
      critical: vulnerabilities.filter(v => v.severity === 'critical').length,
      high: vulnerabilities.filter(v => v.severity === 'high').length,
      moderate: vulnerabilities.filter(v => v.severity === 'moderate').length,
      low: vulnerabilities.filter(v => v.severity === 'low').length,
    };
  }

  /**
   * Get vulnerabilities from cache
   */
  getFromCache(key) {
    try {
      const stmt = this.db.prepare(
        'SELECT data FROM vulnerabilities WHERE id = ? AND expires_at > ?'
      );
      const row = stmt.get(key, Date.now());
      if (row) {
        return JSON.parse(row.data);
      }
    } catch (error) {
      console.error('Cache read error:', error);
    }
    return null;
  }

  /**
   * Save vulnerabilities to cache
   */
  saveToCache(key, data) {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO vulnerabilities (id, ecosystem, package, version, source, data, cached_at, expires_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);
      const now = Date.now();
      stmt.run(
        key,
        data.ecosystem,
        data.package,
        data.version || null,
        'OSV+NPM',
        JSON.stringify(data),
        now,
        now + this.cacheTTL
      );
    } catch (error) {
      console.error('Cache write error:', error);
    }
  }

  /**
   * Get CVE from cache
   */
  getCVEFromCache(cveId) {
    try {
      const stmt = this.db.prepare(
        'SELECT data FROM cve_cache WHERE cve_id = ? AND expires_at > ?'
      );
      const row = stmt.get(cveId, Date.now());
      if (row) {
        return JSON.parse(row.data);
      }
    } catch (error) {
      console.error('CVE cache read error:', error);
    }
    return null;
  }

  /**
   * Save CVE to cache
   */
  saveCVEToCache(cveId, data) {
    try {
      const stmt = this.db.prepare(`
        INSERT OR REPLACE INTO cve_cache (cve_id, data, cached_at, expires_at)
        VALUES (?, ?, ?, ?)
      `);
      const now = Date.now();
      stmt.run(cveId, JSON.stringify(data), now, now + this.cacheTTL);
    } catch (error) {
      console.error('CVE cache write error:', error);
    }
  }

  /**
   * Start the server
   */
  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Vulnerability DB MCP server running on stdio');
  }
}

// Start server if run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const server = new VulnerabilityDBServer();
  server.start().catch(console.error);
}

export { VulnerabilityDBServer };
