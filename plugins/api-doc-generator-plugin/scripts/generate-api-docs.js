#!/usr/bin/env node
/**
 * Generate API Documentation
 * Creates documentation from source code, OpenAPI specs, or annotations
 */

const fs = require('fs');
const path = require('path');

/**
 * API Documentation Generator
 */
class ApiDocGenerator {
  constructor() {
    this.endpointRegex = {
      express: /@(GET|POST|PUT|PATCH|DELETE|OPTIONS)\s*\(\s*['"]([^'"]+)['"]/g,
      fastify: /@(GET|POST|PUT|PATCH|DELETE|OPTIONS)\s*\(\s*['"]([^'"]+)['"]/g,
      python: /@(app|router)\.(get|post|put|patch|delete)\(['"]([^'"]+)['"]/gim,
      java: /@(GetMapping|PostMapping|PutMapping|DeleteMapping|PatchMapping)\(\s*(?:value\s*=\s*)?['"]([^'"]+)['"]/g,
    };
  }

  /**
   * Detect framework from file content
   */
  detectFramework(content) {
    if (content.includes('@RestController') || content.includes('@Controller')) {
      return 'spring';
    }
    if (content.includes('def ') && (content.includes('app.') || content.includes('router.'))) {
      return 'fastapi';
    }
    if (content.includes('app.') || content.includes('router.')) {
      return 'express';
    }
    return 'unknown';
  }

  /**
   * Extract endpoints from source code
   */
  extractEndpoints(content, framework) {
    const endpoints = [];
    const regex = this.endpointRegex[framework] || this.endpointRegex.express;
    let match;

    while ((match = regex.exec(content)) !== null) {
      endpoints.push({
        method: match[1].toUpperCase(),
        path: match[2] || match[3],
        line: this.getLineNumber(content, match.index),
      });
    }

    return endpoints;
  }

  /**
   * Get line number from content index
   */
  getLineNumber(content, index) {
    return content.substring(0, index).split('\n').length;
  }

  /**
   * Generate Markdown documentation
   */
  generateMarkdown(endpoints, specName = 'API') {
    const lines = [];

    lines.push('# API Documentation\n');
    lines.push(`Generated from: ${specName}\n`);
    lines.push('## Endpoints\n');

    // Group by method
    const byMethod = {};
    for (const ep of endpoints) {
      if (!byMethod[ep.method]) {
        byMethod[ep.method] = [];
      }
      byMethod[ep.method].push(ep);
    }

    for (const method of ['GET', 'POST', 'PUT', 'PATCH', 'DELETE']) {
      if (byMethod[method]) {
        for (const ep of byMethod[method]) {
          lines.push(`### ${method} ${ep.path}`);
          lines.push('');
          lines.push('- **Line**: ${ep.line}');
          lines.push('');
        }
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate OpenAPI specification
   */
  generateOpenApi(endpoints, specName = 'API') {
    const paths = {};

    for (const ep of endpoints) {
      if (!paths[ep.path]) {
        paths[ep.path] = {};
      }
      paths[ep.path][ep.method.toLowerCase()] = {
        summary: `${ep.method} endpoint`,
        responses: {
          '200': { description: 'Successful response' },
          '400': { description: 'Bad request' },
          '500': { description: 'Server error' },
        },
      };
    }

    return {
      openapi: '3.0.0',
      info: {
        title: specName,
        version: '1.0.0',
        description: 'API documentation generated by claude-code plugin',
      },
      paths,
    };
  }

  /**
   * Process file or directory
   */
  async process(pathSpec, format = 'markdown', output = 'API.md') {
    const content = await this.readPath(pathSpec);
    if (!content) {
      throw new Error(`Could not read: ${pathSpec}`);
    }

    const framework = this.detectFramework(content);
    const endpoints = this.extractEndpoints(content, framework);

    let result;
    let outputPath = output;

    switch (format) {
      case 'openapi':
        result = JSON.stringify(this.generateOpenApi(endpoints, pathSpec), null, 2);
        if (!outputPath.endsWith('.json')) {
          outputPath = outputPath.replace(/\.[^.]+$/, '.json');
        }
        break;
      case 'json':
        result = JSON.stringify({ endpoints, framework }, null, 2);
        if (!outputPath.endsWith('.json')) {
          outputPath = outputPath.replace(/\.[^.]+$/, '.json');
        }
        break;
      case 'html':
        result = this.generateHtml(endpoints, pathSpec);
        if (!outputPath.endsWith('.html')) {
          outputPath = outputPath.replace(/\.[^.]+$/, '.html');
        }
        break;
      default:
        result = this.generateMarkdown(endpoints, pathSpec);
        if (!outputPath.endsWith('.md')) {
          outputPath = outputPath.replace(/\.[^.]+$/, '.md');
        }
    }

    await fs.promises.writeFile(outputPath, result);
    return { format, outputPath, endpointCount: endpoints.length, framework };
  }

  /**
   * Read file or directory contents
   */
  async readPath(pathSpec) {
    try {
      const stat = await fs.promises.stat(pathSpec);
      if (stat.isDirectory()) {
        const files = await fs.promises.readdir(pathSpec);
        const contents = await Promise.all(
          files
            .filter(f => f.endsWith('.js') || f.endsWith('.ts') || f.endsWith('.py') || f.endsWith('.java'))
            .map(f => this.readPath(path.join(pathSpec, f)))
        );
        return contents.join('\n');
      }
      return await fs.promises.readFile(pathSpec, 'utf-8');
    } catch {
      return null;
    }
  }

  /**
   * Generate HTML documentation
   */
  generateHtml(endpoints, specName) {
    return `<!DOCTYPE html>
<html>
<head>
  <title>API Documentation - ${specName}</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    .endpoint { border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 5px; }
    .GET { border-left: 4px solid #61affe; }
    .POST { border-left: 4px solid #49cc90; }
    .PUT { border-left: 4px solid #fca130; }
    .DELETE { border-left: 4px solid #f93e3e; }
    .method { font-weight: bold; }
    .path { font-family: monospace; }
  </style>
</head>
<body>
  <h1>API Documentation</h1>
  <p>Generated from: ${specName}</p>
  <p>Total endpoints: ${endpoints.length}</p>
  ${endpoints.map(ep => `
  <div class="endpoint ${ep.method}">
    <span class="method">${ep.method}</span> <span class="path">${ep.path}</span>
  </div>`).join('\n')}
</body>
</html>`;
  }
}

/**
 * Main CLI
 */
async function main() {
  const args = process.argv.slice(2);
  const generator = new ApiDocGenerator();

  let pathSpec = '.';
  let format = 'markdown';
  let output = 'API.md';

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--path' || arg === '-p') {
      pathSpec = args[++i] || '.';
    } else if (arg === '--format' || arg === '-f') {
      format = args[++i] || 'markdown';
    } else if (arg === '--output' || arg === '-o') {
      output = args[++i] || 'API.md';
    } else if (!arg.startsWith('--')) {
      pathSpec = arg;
    }
  }

  try {
    const result = await generator.process(pathSpec, format, output);
    console.log(`Generated ${result.endpointCount} endpoints in ${result.outputPath}`);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = ApiDocGenerator;